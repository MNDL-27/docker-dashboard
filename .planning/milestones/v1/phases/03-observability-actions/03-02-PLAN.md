---
phase: 03-observability-actions
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/api/src/index.ts
  - apps/api/package.json
  - apps/api/src/websocket/server.ts
  - apps/api/src/websocket/auth.ts
autonomous: true
requirements:
  - METR-04
  - LOGS-04
  - ACTN-06

must_haves:
  truths:
    - API exposes a WebSocket server alongside Express
    - Agents can connect to `/ws/agent/:hostId` and authenticate
    - Web UI can connect to `/ws/client` and authenticate
  artifacts:
    - path: apps/api/src/websocket/server.ts
      provides: WebSocket server integration
    - path: apps/api/src/websocket/auth.ts
      provides: WebSocket authentication logic using JWT/tickets
---

<objective>
Implement the core WebSocket infrastructure in the Cloud API. This allows bi-directional communication necessary for real-time metrics streaming, log tailing, and sending action commands to agents behind firewalls.
</objective>

<execution_context>
@C:/Users/proti/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/phases/03-observability-actions/RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebSocket Dependencies</name>
  <files>apps/api/package.json</files>
  <action>
Add `ws` and `@types/ws` to the `apps/api` package:
- Run `npm install ws` inside `apps/api`.
- Run `npm install -D @types/ws` inside `apps/api`.
  </action>
  <verify>cat package.json | grep ws</verify>
  <done>ws package is listed in dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Implement WebSocket Auth Logic</name>
  <files>apps/api/src/websocket/auth.ts</files>
  <action>
Create `apps/api/src/websocket/auth.ts`:
- Export a function `authenticateWebSocket(req: http.IncomingMessage)`
- For Agents: Extract Bearer token from `Authorization` header OR via a `?token=` query param. Verify using `AGENT_JWT_SECRET` and return inferred `hostId` and `organizationId`.
- For Web Clients: Extract JWT from cookie if sent via standard handshake headers, or expect a short-lived ticket in URL param `?ticket=...`. We will start with standard cookie reading if possible, or query param containing the user's session token. Verify secret and return `userId` and associated `organizationId`s.
  </action>
  <verify>tsc --noEmit</verify>
  <done>Auth logic handles both agent and client connection handshakes</done>
</task>

<task type="auto">
  <name>Task 3: Integrate WS Server into Express</name>
  <files>apps/api/src/index.ts, apps/api/src/websocket/server.ts</files>
  <action>
Modify `apps/api/src/index.ts` to attach a WebSocket server to the HTTP server instance.
- Create `apps/api/src/websocket/server.ts` storing active connections mapped by `hostId` (for agents) and `userId`/`orgId` (for clients).
- In `index.ts`: `const server = app.listen(...)`
- Attach `new WebSocketServer({ noServer: true })`
- Handle `server.on('upgrade', ...)` to perform `authenticateWebSocket`. If it passes, pass the socket to the WSS instance. Set up basic ping/pong to keep connections alive.
  </action>
  <verify>tsc --noEmit</verify>
  <done>HTTP server upgrades valid connections to secure WebSockets</done>
</task>

</tasks>

<verification>
Ensure `npm run build` in `apps/api` compiles successfully. Verify `ws` dependencies are correctly imported and configured on the main Express HTTP server.
</verification>

<success_criteria>
- Express server accepts WebSocket upgrades
- Connections are securely authenticated before upgrade completes
- Active connections map is maintained in memory
</success_criteria>

<output>
After completion, create .planning/phases/03-observability-actions/03-02-SUMMARY.md
</output>
