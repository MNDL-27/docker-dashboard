---
phase: 4
plan: 02
wave: 2
depends_on: [01]
files_modified:
  - apps/api/src/services/alertEngine.ts
  - apps/api/src/app.ts
  - apps/api/src/routes/webhooks.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "System evaluates rules efficiently against latest metrics"
    - "System triggers webhooks payload properly on Alert Firing"
    - "System resolves Alerts that no longer meet criteria"
  artifacts:
    - path: "apps/api/src/services/alertEngine.ts"
      provides: "Background evaluation loop"
    - path: "apps/api/src/routes/webhooks.ts"
      provides: "CRUD for webhook endpoints"
---

# Plan 04-02: Alert Evaluation Engine & Webhooks

<objective>
Implement a background service within the Cloud API that periodically evaluates `AlertRule` thresholds against the latest telemetry, triggering and resolving `Alert` events accordingly. Also implement a router to manage an organization's `Webhook` integrations.
</objective>

<context>
Load for context:
- .planning/ROADMAP.md
- apps/api/src/app.ts
- apps/api/src/services/alertEngine.ts (new)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Webhook API Routes</name>
  <files>apps/api/src/routes/webhooks.ts</files>
  <action>
Implement standard CRUD API endpoints for Webhooks (`GET /`, `POST /`, `PUT /:id`, `DELETE /:id`).
Ensure they enforce RBAC (Operator+ can view, Admin+ can modify).
Mount this router in `apps/api/src/app.ts` under `/api/webhooks`.
  </action>
  <verify>curl or similar tools to fetch /api/webhooks with auth.</verify>
  <done>Webhook router is mounted and handles CRUD.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Background Alert Engine Service</name>
  <files>apps/api/src/services/alertEngine.ts</files>
  <action>
Create `evaluateRules()`, triggered via an interval (e.g. every 1 minute) from `app.ts` or a worker layer:

1. Fetch all active `Container` records joined with their `Host`.
2. Fetch the corresponding Organization's `AlertRule` configurations.
3. Compare:
   - `CONTAINER_DOWN`: Container status `exited` and `updatedAt` older than threshold `duration`.
   - `RESTART_LOOP`: Compare Agent metrics (or derived from status string) to deduce restarts.
   - `CPU_USAGE`: Query `ContainerMetric` for `cpuUsagePercent > threshold`.
   - `MEMORY_USAGE`: Query `ContainerMetric` for `memoryUsageBytes > threshold`.
4. If a condition persists beyond `duration`:
   - Check if an `Alert` is already `FIRING` for this `ruleId` + `containerId` combination.
   - If not, create an `Alert` marked `FIRING` and queue Webhook payload.
5. If a condition is no longer met but an `Alert` exists as `FIRING`:
   - Mark as `RESOLVED`. Queue Webhook payload indicating resolution.
  </action>
  <verify>Execute the service manually or via unit tests to verify firing state transitions.</verify>
  <done>Alert engine correctly executes the state machine for basic CPU/Mem/Down conditions.</done>
</task>

<task type="auto">
  <name>Task 3: Implement Webhook Dispatcher</name>
  <files>apps/api/src/services/alertEngine.ts</files>
  <action>
Create a `dispatchWebhook(alert, eventType)` function:
1. Fetch `Webhook` configs for the Organization where `isActive == true`.
2. Construct JSON payload:
   ```json
   {
     "event": "alert.firing" | "alert.resolved",
     "alert_id": alert.id,
     "rule_name": rule.name,
     "container_name": container.name,
     "host_name": host.name,
     "timestamp": "..."
   }
   ```
3. HTTP POST to `webhook.url`. 
4. Include `X-Docker-Dashboard-Signature` header if `webhook.secret` exists (HMAC SHA-256).
  </action>
  <verify>Inspect server console logs or mock endpoint to verify payload delivery.</verify>
  <done>Firing an alert correctly triggers a fetch and POST to active Webhooks.</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] API has `/api/webhooks` available for creation.
- [ ] `alertEngine` loop starts on server boot.
- [ ] Engine tests against simulated or seeded `ContainerMetric` and creates `Alert` rows.
</verification>

<success_criteria>
- [ ] Engine logic is sound and non-blocking.
- [ ] Alert deduplication works (no duplicate FIRING alerts for the same condition).
</success_criteria>
