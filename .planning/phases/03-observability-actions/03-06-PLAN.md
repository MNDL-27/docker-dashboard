---
phase: 03-observability-actions
plan: 06
type: execute
wave: 5
depends_on: ["03-02", "03-04"]
files_modified:
  - apps/api/src/routes/actions.ts
  - apps/api/src/websocket/server.ts
  - packages/agent/main.go
  - packages/agent/docker/client.go
autonomous: true
requirements:
  - ACTN-06
  - ACTN-07

must_haves:
  truths:
    - Cloud API HTTP endpoints allow POST requests for START/STOP/RESTART
    - Cloud API relays action requests over WebSocket to the specific Agent
    - Agent executes the Docker action and reports the result back
  artifacts:
    - path: apps/api/src/routes/actions.ts
      provides: REST interface for initiating container actions
    - path: packages/agent/docker/client.go
      provides: Executing container start/stop/restart
---

<objective>
Implement the Action Relay mechanism. This allows the cloud to trigger START, STOP, or RESTART commands on a container by sending a message over the agent's persistent WebSocket, and handling the success/fail response.
</objective>

<execution_context>
@C:/Users/proti/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/phases/03-observability-actions/RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build Action REST API</name>
  <files>apps/api/src/routes/actions.ts, apps/api/src/index.ts, apps/api/src/websocket/server.ts</files>
  <action>
Create the REST controller for UI requests:
- Create `POST /api/containers/:containerId/actions` expecting a JSON body `{ "action": "START|STOP|RESTART", "reason": "string" }`
- Find the `hostId` for the requested container.
- Export a function `sendActionToAgent(hostId, actionPayload)` from `websocket/server.ts`. This iterates over the active WS connection map, finds the right agent, and calls `ws.send()`.
- Wait for a response acknowledgement from the agent over WS (you can implement a basic promise-based message listener keyed by a generated `action_id`), or simply return `202 Accepted` to the UI and let the UI wait for the container status to update naturally. Returning `200` with the agent's actual success/fail result is ideal.
  </action>
  <verify>tsc --noEmit</verify>
  <done>API successfully parses action requests and relays them over WS</done>
</task>

<task type="auto">
  <name>Task 2: Agent WebSocket Action Listener</name>
  <files>packages/agent/main.go</files>
  <action>
Update the Go Agent WebSocket loop:
- Instead of just catching disconnects, explicitly read from the WebSocket continuously: `for { _, msg, err := conn.ReadMessage() ... }`
- If `msg` is of type `action`, parse the `WaitMsBeforeAsync` id, the `containerId`, and the `action` string (START, STOP, RESTART).
- Call `ExecuteAction(containerId, action)` (to be implemented).
- Construct a response payload `{ "type": "action_result", "action_id": "...", "status": "SUCCESS|FAILURE", "error": "..." }` and write it back over the WebSocket to the Cloud.
  </action>
  <verify>go build ./...</verify>
  <done>Agent parses Action WS messages and responds with results</done>
</task>

<task type="auto">
  <name>Task 3: Implement Agent Docker Execution</name>
  <files>packages/agent/docker/client.go</files>
  <action>
Add execution methods to the Docker client:
- Implement `StartContainer(id string) error` via Docker API `POST /containers/{id}/start`
- Implement `StopContainer(id string) error` via Docker API `POST /containers/{id}/stop`
- Implement `RestartContainer(id string) error` via Docker API `POST /containers/{id}/restart`
  </action>
  <verify>go build ./docker</verify>
  <done>Agent executes actual lifecycle commands against local Docker daemon</done>
</task>

</tasks>

<verification>
Ensure both the node API and Go Agent compile successfully without errors.
</verification>

<success_criteria>
- A secure REST API triggers a WebSocket command to the agent.
- The agent securely executes the Docker command.
- The agent responds with the precise result of the command execution over the same socket.
</success_criteria>

<output>
After completion, create .planning/phases/03-observability-actions/03-06-SUMMARY.md
</output>
