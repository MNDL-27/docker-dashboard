---
phase: 03-observability-actions
plan: 08
type: execute
wave: 7
depends_on: ["03-01", "03-06"]
files_modified:
  - apps/api/src/routes/actions.ts
  - apps/api/src/routes/audit.ts
  - apps/web/src/app/(dashboard)/audit/page.tsx
autonomous: true
requirements:
  - AUDT-01
  - AUDT-02
  - AUDT-03
  - AUDT-04

must_haves:
  truths:
    - Every REST action request creates an AuditLog record
    - AuditLog records contain actor_user_id, target, timestamp, and success/fail status
    - Web UI provides a page to view the organization's audit log
  artifacts:
    - path: apps/api/src/routes/audit.ts
      provides: Data fetching for the audit log table
    - path: apps/web/src/app/(dashboard)/audit/page.tsx
      provides: UI for viewing the audit log
---

<objective>
Implement the Audit Logging requirement. This ensures every container action executed securely logs the "who, what, when, and result" to the database, fulfilling compliance and observability metrics.
</objective>

<execution_context>
@C:/Users/proti/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/phases/03-observability-actions/RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate Audit into Action API</name>
  <files>apps/api/src/routes/actions.ts</files>
  <action>
Modify the existing lifecycle action API:
- Before or immediately after fulfilling the action request (relaying via WebSocket), insert an `AuditLog` record into Prisma.
- Set `userId` from `req.user.id`.
- Set `organizationId` from context.
- Set `action`, `targetType: 'CONTAINER'`, `targetId: containerId`, `reason` from the request.
- Based on the Agent's WebSocket response (or API sync point), set `status` to `SUCCESS` or `FAILURE` and include any `errorDetails`.
  </action>
  <verify>tsc --noEmit</verify>
  <done>API successfully writes AuditLog records alongside action triggers</done>
</task>

<task type="auto">
  <name>Task 2: Build Audit Listing API</name>
  <files>apps/api/src/routes/audit.ts, apps/api/src/index.ts</files>
  <action>
Create the REST endpoint for fetching audit logs:
- Create `GET /api/audit` (or `/api/organizations/:orgId/audit`)
- Fetch records from `AuditLog` ordered by `createdAt` descending. Include the `User` relation to return the user's email/name.
- Enforce standard JWT authentication and RBAC (Viewer+ should be able to see logs, or Admin+ if you decide to restrict it).
- Register the router in `index.ts`.
  </action>
  <verify>tsc --noEmit</verify>
  <done>API returns sorted and authenticated audit log statements</done>
</task>

<task type="auto">
  <name>Task 3: Build Web UI Audit Page</name>
  <files>apps/web/src/app/(dashboard)/audit/page.tsx</files>
  <action>
Create the frontend Audit Log Viewer:
- Implement a new Next.js page `/audit` within the dashboard layout.
- Fetch data from `GET /api/audit`.
- Render a table showing: Timestamp, User (email), Action, Target Container, Reason, and Status.
- Color code actions (e.g., START is green, STOP is red) and statuses (SUCCESS/FAILURE).
  </action>
  <verify>npm run build</verify>
  <done>Web UI displays full historical context of all platform actions</done>
</task>

</tasks>

<verification>
Ensure both API and Web projects compile successfully. Verify the routing paths line up properly.
</verification>

<success_criteria>
- Audit table is populated during action invocation.
- Platform provides a dedicated page for admins/users to view history.
- The history includes exact details on who performed what action.
</success_criteria>

<output>
After completion, create .planning/phases/03-observability-actions/03-08-SUMMARY.md
</output>
